const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const dns = require("dns").promises;
const net = require("net");
const OpenAI = require("openai");

const RUNNER_VERSION = "JARVIS_RUNNER_AUDIT_SSOT_V1_2026-01-30";

// ---------- helpers ----------
function safeMkdir(dir) { try { fs.mkdirSync(dir, { recursive: true }); } catch (_) {} }

function sha256Text(txt) {
  return crypto.createHash("sha256").update(String(txt || ""), "utf8").digest("hex");
}

function clip(s, max) {
  const t = String(s || "");
  return t.length <= max ? t : t.slice(0, max) + "…";
}

function normOneLine(s) { return String(s || "").replace(/\s+/g, " ").trim(); }

function writeFileProof(filePath, content) {
  const data = String(content || "");
  safeMkdir(path.dirname(filePath));
  fs.writeFileSync(filePath, data, "utf8");
  return { path: filePath, bytes: Buffer.byteLength(data, "utf8"), sha256: sha256Text(data) };
}

function compactHistory(history, maxTurns = 10, maxChars = 360) {
  const arr = Array.isArray(history) ? history : [];
  const clean = arr
    .filter((m) => m && (m.role === "user" || m.role === "assistant") && typeof m.content === "string")
    .map((m) => ({ role: m.role, content: clip(normOneLine(m.content), maxChars) }));
  return clean.slice(-maxTurns);
}

function wantsTauriAction(taskText) {
  const t = String(taskText || "").toLowerCase();
  return t.includes("tauri") && (t.includes("prepare") || t.includes("prepara") || t.includes("setup") || t.includes("scaffold") || t.includes("create"));
}

function makeRunId() {
  const iso = new Date().toISOString().replace(/:/g, "-").replace(/\./g, "-");
  return `RUN_${iso}`;
}

function appDataRoot() {
  const a = process.env.APPDATA ? String(process.env.APPDATA) : "";
  if (a) return path.join(a, "jarvis_electron_v1");
  return path.join(process.cwd(), "jarvis_electron_v1");
}

function nowISO() { return new Date().toISOString(); }

// ---------- Permissions (Phase 0 baseline) ----------
function loadPermissions(opts) {
  const defaults = {
    web_search: true,
    web_fetch: true,
    web_read: true,
    tauri_plan: true,
    cmd_exec: false,
    download: false,
    ssot_write: true,
    audit_write: true,
  };

  // file-based config (no UI changes)
  const cfgPath = path.join(appDataRoot(), "jarvis_permissions.json");
  let fileCfg = {};
  try {
    if (fs.existsSync(cfgPath)) {
      const raw = fs.readFileSync(cfgPath, "utf8");
      fileCfg = JSON.parse(raw);
    }
  } catch (_) { fileCfg = {}; }

  // optional runtime override (if UI ever passes it)
  const runtimeCfg = (opts && typeof opts.permissions === "object" && opts.permissions) ? opts.permissions : {};

  return Object.assign({}, defaults, fileCfg || {}, runtimeCfg || {});
}

// ---------- Audit (append-only JSONL) ----------
function auditAppendLine(lineObj, perms) {
  if (!perms || perms.audit_write !== true) return;
  const root = appDataRoot();
  const dir = path.join(root, "audit");
  const file = path.join(dir, "audit.jsonl");
  safeMkdir(dir);
  const row = JSON.stringify(lineObj) + "\n";
  try { fs.appendFileSync(file, row, "utf8"); } catch (_) {}
}

function ssotPath(baseRoot) {
  return path.join(String(baseRoot || process.cwd()), "SSOT_JARVIS.md");
}

function ensureSSOT(baseRoot) {
  const p = ssotPath(baseRoot);
  if (fs.existsSync(p)) return p;

  const tmpl =
`# JARVIS DESKTOP — SSOT (Single Source of Truth)

**Last update:** ${nowISO()}
**Runner version:** ${RUNNER_VERSION}

## Goal
JARVIS deve lavorare come “noi due”: search → read → plan → file ops → cmd step-by-step con permessi progressivi e proof/audit.

Pilastri: **Tooling / Permessi / Proof-Audit**

## Paths (SSOT)
- Workspace: C:\\Users\\Utente\\TEST GPT HOME MADE\\versione 008\\JARVIS_ELECTRON_V1\\
- Proofs runtime: %AppData%\\Roaming\\jarvis_electron_v1\\proofs\\RUN_*.json
- Audit log: %AppData%\\Roaming\\jarvis_electron_v1\\audit\\audit.jsonl

## Implemented features (log)
(append-only)
`;
  writeFileProof(p, tmpl);
  return p;
}

function ssotAppend(baseRoot, text, perms) {
  if (!perms || perms.ssot_write !== true) return;
  const p = ensureSSOT(baseRoot);
  try {
    const stamp = `\n- ${nowISO()} ${text}\n`;
    fs.appendFileSync(p, stamp, "utf8");
  } catch (_) {}
}
// ---------- WEB GUARD ----------
function isPrivateOrReservedIP(ip) {
  const v = net.isIP(ip);
  if (!v) return true;

  if (v === 4) {
    const [a,b] = ip.split(".").map(n => parseInt(n,10));
    if (a === 10) return true;
    if (a === 127) return true;
    if (a === 0) return true;
    if (a === 169 && b === 254) return true;
    if (a === 172 && b >= 16 && b <= 31) return true;
    if (a === 192 && b === 168) return true;
    if (a === 100 && b >= 64 && b <= 127) return true;
    if (a >= 224) return true;
    return false;
  }

  const low = ip.toLowerCase();
  if (low === "::1") return true;
  if (low.startsWith("fe80:")) return true;
  if (low.startsWith("fc") || low.startsWith("fd")) return true;
  if (low.startsWith("::ffff:127.")) return true;
  return false;
}

async function assertPublicHost(host) {
  const h = String(host || "").trim().toLowerCase();
  if (!h) throw new Error("WEB_BAD_HOST");
  if (h === "localhost" || h.endsWith(".local")) throw new Error("WEB_BLOCKED_HOST");

  if (net.isIP(h)) {
    if (isPrivateOrReservedIP(h)) throw new Error("WEB_BLOCKED_IP");
    return;
  }

  let ips = [];
  try { ips = await dns.lookup(h, { all: true, verbatim: true }); }
  catch (_) { throw new Error("WEB_DNS_FAIL"); }

  if (!ips || !ips.length) throw new Error("WEB_DNS_EMPTY");
  for (const r of ips) {
    if (r && r.address && isPrivateOrReservedIP(r.address)) throw new Error("WEB_BLOCKED_IP");
  }
}

function stripHtmlToText(html) {
  let s = String(html || "");
  s = s.replace(/<script[\s\S]*?<\/script>/gi, " ");
  s = s.replace(/<style[\s\S]*?<\/style>/gi, " ");
  s = s.replace(/<\/(p|div|br|li|h1|h2|h3|h4|h5|h6)>/gi, "\n");
  s = s.replace(/<[^>]+>/g, " ");
  s = s.replace(/&nbsp;/g, " ");
  s = s.replace(/&amp;/g, "&");
  s = s.replace(/&lt;/g, "<");
  s = s.replace(/&gt;/g, ">");
  s = s.replace(/\n{3,}/g, "\n\n");
  s = s.replace(/[ \t]{2,}/g, " ");
  return s.trim();
}

async function readLimitedBody(body, maxBytes) {
  if (!body) return Buffer.from("");
  const reader = body.getReader ? body.getReader() : null;
  if (!reader) {
    const ab = await body.arrayBuffer();
    const buf = Buffer.from(ab);
    if (buf.length > maxBytes) throw new Error("WEB_TOO_LARGE");
    return buf;
  }
  const chunks = [];
  let total = 0;
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    const b = Buffer.from(value);
    total += b.length;
    if (total > maxBytes) throw new Error("WEB_TOO_LARGE");
    chunks.push(b);
  }
  return Buffer.concat(chunks);
}

async function webFetchGuarded(urlStr, opts) {
  const maxBytes = opts.maxBytes || 900_000;
  const timeoutMs = opts.timeoutMs || 8000;
  const maxRedirects = opts.maxRedirects || 4;

  let current = new URL(urlStr);
  if (!/^https?:$/.test(current.protocol)) throw new Error("WEB_BAD_PROTOCOL");

  for (let i = 0; i <= maxRedirects; i++) {
    await assertPublicHost(current.hostname);

    const ac = new AbortController();
    const t = setTimeout(() => ac.abort(), timeoutMs);
    let res;
    try {
      res = await fetch(current.toString(), {
        method: "GET",
        redirect: "manual",
        headers: {
          "User-Agent": "JARVIS_ELECTRON_V1/1.0",
          "Accept": "text/html,application/json,text/plain,*/*",
        },
        signal: ac.signal,
      });
    } catch (e) {
      clearTimeout(t);
      throw new Error(ac.signal.aborted ? "WEB_TIMEOUT" : "WEB_FETCH_FAIL");
    }
    clearTimeout(t);

    const status = res.status;
    const loc = res.headers.get("location");
    const ct = res.headers.get("content-type") || "";

    if (status >= 300 && status < 400 && loc) {
      const next = new URL(loc, current);
      if (!/^https?:$/.test(next.protocol)) throw new Error("WEB_BAD_PROTOCOL");
      current = next;
      continue;
    }

    const buf = await readLimitedBody(res.body, maxBytes);
    const raw = buf.toString("utf8");
    const text = /text\/html/i.test(ct) ? stripHtmlToText(raw) : raw;

    return {
      ok: true,
      status,
      finalUrl: current.toString(),
      contentType: ct,
      bytes: buf.length,
      sha256: sha256Text(raw),
      raw,
      text,
    };
  }

  throw new Error("WEB_TOO_MANY_REDIRECTS");
}

function parseWebCommand(taskText) {
  const t = String(taskText || "").trim();
  if (!t.toUpperCase().startsWith("WEB:")) return null;

  const rest = t.slice(4).trim();
  if (!rest) return { error: "WEB_EMPTY" };

  const parts = rest.split("|").map(s => s.trim()).filter(Boolean);
  const url = parts[0] || "";
  const q = parts.slice(1).join(" | ").trim();
  return { url, question: q };
}

// ---------- SEARCH (provider: Brave if key else DDG HTML) ----------
function parseSearchCommand(taskText) {
  const t = String(taskText || "").trim();
  if (!t.toUpperCase().startsWith("SEARCH:")) return null;
  const q = t.slice(7).trim();
  if (!q) return { error: "SEARCH_EMPTY" };
  return { query: q };
}

function extractAutoSearchQuery(taskText) {
  const s0 = normOneLine(taskText);
  if (!s0) return null;

  const low = s0.toLowerCase();
  if (low.startsWith("non cerc") || low.startsWith("non tro")) return null;
  if (/https?:\/\/\S+/i.test(s0)) return null;

  const patterns = [
    [/^(cercami|cerca|trovami|trova)\s+(su\s+google\s+)?/i, ""],
    [/^(informazioni|info)\s+su\s+/i, ""],
    [/^(search|find|look\s*up)\s+/i, ""],
  ];

  for (const [re, rep] of patterns) {
    if (re.test(s0)) {
      const q = s0.replace(re, rep).trim();
      return q || null;
    }
  }

  const m = s0.match(/\b(cerca(mi)?|trova(mi)?)\b(?:\s+su\s+google|\s+online|\s+sul\s+web)?\s+(.+)$/i);
  if (m && m[3]) {
    const q = String(m[3]).trim();
    return q || null;
  }

  return null;
}

function decodeHtmlEntitiesBasic(s) {
  let t = String(s || "");
  t = t.replace(/&nbsp;/g, " ");
  t = t.replace(/&amp;/g, "&");
  t = t.replace(/&quot;/g, '"');
  t = t.replace(/&#39;/g, "'");
  t = t.replace(/&lt;/g, "<");
  t = t.replace(/&gt;/g, ">");
  t = t.replace(/&#(\d+);/g, (_, n) => {
    const code = parseInt(n, 10);
    if (!isFinite(code)) return _;
    try { return String.fromCharCode(code); } catch { return _; }
  });
  return t;
}

function stripTags(s) {
  return decodeHtmlEntitiesBasic(String(s || "").replace(/<[^>]+>/g, " ")).replace(/\s+/g, " ").trim();
}

function normalizeDdgUrl(u) {
  const s = String(u || "").trim();
  try {
    const url = new URL(s);
    const uddg = url.searchParams.get("uddg");
    if (uddg) return decodeURIComponent(uddg);
  } catch (_) {}
  return s;
}

function parseDdgHtmlResults(html, maxResults) {
  const raw = String(html || "");
  const results = [];
  const linkRe = /<a[^>]+class="result__a"[^>]+href="([^"]+)"[^>]*>([\s\S]*?)<\/a>/gi;

  let m;
  while ((m = linkRe.exec(raw)) && results.length < maxResults) {
    let url = stripTags(m[1] || "");
    url = normalizeDdgUrl(url);
    const title = stripTags(m[2] || "");
    if (!url || !title) continue;

    const windowStart = Math.max(0, m.index);
    const windowEnd = Math.min(raw.length, m.index + 2000);
    const chunk = raw.slice(windowStart, windowEnd);

    let snippet = "";
    const sn = chunk.match(/class="result__snippet"[^>]*>([\s\S]*?)<\/(?:a|div)>/i);
    if (sn && sn[1]) snippet = stripTags(sn[1]);

    results.push({ title, url, snippet });
  }
  return results;
}

async function webSearch(query, opts) {
  const q = String(query || "").trim();
  if (!q) throw new Error("SEARCH_EMPTY");

  const maxBytes = opts.maxBytes || 900_000;
  const timeoutMs = opts.timeoutMs || 8000;
  const count = Math.max(1, Math.min(8, opts.count || 5));
  const braveKey = (opts.braveKey || process.env.BRAVE_SEARCH_API_KEY || "").trim();

  if (braveKey) {
    const u = new URL("https://api.search.brave.com/res/v1/web/search");
    u.searchParams.set("q", q);
    u.searchParams.set("count", String(count));

    const ac = new AbortController();
    const t = setTimeout(() => ac.abort(), timeoutMs);
    let res;
    try {
      await assertPublicHost(u.hostname);
      res = await fetch(u.toString(), {
        method: "GET",
        headers: {
          "User-Agent": "JARVIS_ELECTRON_V1/1.0",
          "Accept": "application/json",
          "X-Subscription-Token": braveKey,
        },
        signal: ac.signal,
      });
    } catch (e) {
      clearTimeout(t);
      throw new Error(ac.signal.aborted ? "WEB_TIMEOUT" : "WEB_FETCH_FAIL");
    }
    clearTimeout(t);

    const buf = await readLimitedBody(res.body, maxBytes);
    const raw = buf.toString("utf8");

    let parsed;
    try { parsed = JSON.parse(raw); } catch (_) { throw new Error("SEARCH_BAD_JSON"); }

    const web = parsed && parsed.web && Array.isArray(parsed.web.results) ? parsed.web.results : [];
    const results = web.slice(0, count).map((x) => ({
      title: normOneLine(x && x.title ? x.title : ""),
      url: String(x && (x.url || x.link) ? (x.url || x.link) : "").trim(),
      snippet: normOneLine(x && (x.description || x.snippet) ? (x.description || x.snippet) : ""),
    })).filter((x) => x.title && x.url);

    return {
      provider: "brave",
      query: q,
      results,
      raw,
      raw_sha256: sha256Text(raw),
      raw_bytes: buf.length,
      status: res.status,
      contentType: res.headers.get("content-type") || "",
    };
  }

  const ddgUrl = "https://html.duckduckgo.com/html/?q=" + encodeURIComponent(q);
  const r = await webFetchGuarded(ddgUrl, { maxBytes, timeoutMs, maxRedirects: 2 });
  const results = parseDdgHtmlResults(r.raw || "", count);
  return {
    provider: "ddg_html",
    query: q,
    results,
    raw: r.raw || "",
    raw_sha256: sha256Text(r.raw || ""),
    raw_bytes: Buffer.byteLength(String(r.raw || ""), "utf8"),
    status: r.status,
    contentType: r.contentType,
  };
}
function formatSearchForPrompt(searchObj) {
  const provider = searchObj.provider || "unknown";
  const results = Array.isArray(searchObj.results) ? searchObj.results : [];
  const lines = [];
  lines.push(`SEARCH_PROVIDER: ${provider}`);
  lines.push(`SEARCH_QUERY: ${searchObj.query || ""}`);
  lines.push(`SEARCH_RESULTS: ${results.length}`);
  results.slice(0, 8).forEach((r, i) => {
    lines.push(`${i + 1}. ${r.title || ""}`);
    lines.push(`   URL: ${r.url || ""}`);
    if (r.snippet) lines.push(`   SNIPPET: ${r.snippet}`);
  });
  return lines.join("\n");
}

// ---------- core ----------
async function runTask(opts) {
  const apiKey = String(opts.apiKey || "").trim();
  const taskTextRaw = String(opts.taskText || "").trim();
  const baseRoot = opts.baseRoot ? String(opts.baseRoot) : process.cwd();
  const proofsDir = opts.proofsDir ? String(opts.proofsDir) : path.join(process.cwd(), "proofs");

  const onLog = typeof opts.onLog === "function" ? opts.onLog : () => {};
  const onStep = typeof opts.onStep === "function" ? opts.onStep : () => {};

  const perms = loadPermissions(opts);

  const MAX_TASK_CHARS = 2500;
  const MAX_RULES_CHARS = 1600;
  const MAX_TURNS = 10;
  const MAX_HIST_CHARS = 360;
  const MAX_WEB_CHARS = 9000;
  const MAX_SEARCH_RAW_CHARS = 14000;

  if (!apiKey) return { ok: false, error: "NO_API_KEY", proofJsonPath: "", fileOps: [] };

  const taskText = clip(taskTextRaw, MAX_TASK_CHARS);
  const rulesUser = clip(String(opts.rulesText || ""), MAX_RULES_CHARS);

  const history = compactHistory(opts.history, MAX_TURNS, MAX_HIST_CHARS);
  const wantsTauri = wantsTauriAction(taskText);

  const runId = makeRunId();
  safeMkdir(proofsDir);
  const proofJsonPath = path.join(proofsDir, `${runId}.json`);
  const fileOps = [];
  const auditEvents = [];

  const step = (title, status, proof) => {
    try { onStep({ title, status, proof: proof || "" }); } catch (_) {}
    auditEvents.push({ kind: "step", at: nowISO(), runId, title, status, proof: proof || "" });
  };

  step("Runner version", "ok", RUNNER_VERSION);

  // SSOT baseline init
  ensureSSOT(baseRoot);

  // Output policy: act like "noi due"
  const outputPolicy =
    "RULES:\n" +
    "- Be direct and realistic.\n" +
    "- If web was used: cite which SOURCE number (SOURCE_1, SOURCE_2) in plain text.\n" +
    "- If insufficient web data: reply INSUFFICIENT_WEB_DATA.\n" +
    "- If the user asks for execution: propose steps + ask for permission/confirm.\n";

  const finalInstructions = `${outputPolicy}\n${rulesUser}`.trim();

  let ctx = "";
  if (history.length) {
    const lines = history.map((m) => `${m.role === "assistant" ? "JARVIS" : "USER"}: ${m.content}`);
    ctx = `HISTORY (last ${history.length} turns):\n${lines.join("\n")}\n\n`;
  }

  // Audit header
  auditAppendLine({ kind: "run_start", at: nowISO(), runId, runner_version: RUNNER_VERSION, taskText, perms }, perms);

  // --- Action branch (tauri) ---
  if (wantsTauri) {
    if (perms.tauri_plan !== true) {
      const err = "PERM_DENY_TAURI_PLAN";
      step("Tauri plan", "error", err);
      auditAppendLine({ kind: "run_end", at: nowISO(), runId, ok: false, error: err }, perms);
      return { ok: false, error: err, proofJsonPath: "", fileOps: [] };
    }

    const tauriDir = path.join(baseRoot, "JARVIS_TAURI_V2");
    safeMkdir(tauriDir);
    step("Create folder JARVIS_TAURI_V2", "ok", tauriDir);

    step("OpenAI call", "running", "Responses API");
    const client = new OpenAI({ apiKey });

    const fullInput = `${ctx}TASK:\n${taskText}`;

    const resp = await client.responses.create({
      model: "gpt-5.2",
      instructions:
        finalInstructions +
        "\n\nProduce a practical plan for scaffolding a Tauri desktop app on Windows. " +
        "Avoid interactive prompts. Include exact commands. Match Electron UI sections (tabs).",
      input: fullInput,
      max_output_tokens: 800,
    });

    const outTextRaw = resp && resp.output_text ? resp.output_text : "(no output_text)";
    const outText = String(outTextRaw);
    step("OpenAI call", "ok", `out_sha256=${sha256Text(outTextRaw)}`);

    const planPath = path.join(tauriDir, "TAURI_PLAN.md");
    const proof1 = writeFileProof(planPath, outText);
    fileOps.push({ op: "write", ...proof1 });
    step("Write TAURI_PLAN.md", "ok", `sha256=${proof1.sha256}`);

    const readmePath = path.join(tauriDir, "README.md");
    const readme = `# JARVIS_TAURI_V2\n\nGenerated by JARVIS Electron V1.\n\nRunId: ${runId}\nTask: ${taskText}\nPlan: TAURI_PLAN.md\n`;
    const proof2 = writeFileProof(readmePath, readme);
    fileOps.push({ op: "write", ...proof2 });
    step("Write README.md", "ok", `sha256=${proof2.sha256}`);

    const proofObj = {
      ok: true, runId, at: nowISO(),
      runner_version: RUNNER_VERSION,
      feature_tag: "TAURI_PLAN",
      taskText, history_count: history.length,
      openai_model: "gpt-5.2",
      output_sha256: sha256Text(outTextRaw),
      perms,
      fileOps,
      audit_steps: auditEvents,
    };
    const proofJson = JSON.stringify(proofObj, null, 2);
    const proof3 = writeFileProof(proofJsonPath, proofJson);
    step("Write proof JSON", "ok", `sha256=${proof3.sha256}`);

    // Flush audit + SSOT
    auditEvents.forEach(ev => auditAppendLine(ev, perms));
    auditAppendLine({ kind: "run_end", at: nowISO(), runId, ok: true, feature_tag: "TAURI_PLAN", proofJsonPath }, perms);
    ssotAppend(baseRoot, `DONE_OK TAURI_PLAN runId=${runId} proof=${proofJsonPath}`, perms);

    onLog("DONE.");
    return { ok: true, answer: outText, proofJsonPath, fileOps };
  }

  // --- SEARCH branch (explicit SEARCH: OR auto "cercami...") ---
  const explicitSearch = parseSearchCommand(taskText);
  const autoQ = !explicitSearch ? extractAutoSearchQuery(taskText) : null;
  const searchQ = explicitSearch && !explicitSearch.error ? explicitSearch.query : autoQ;

  if (searchQ) {
    if (perms.web_search !== true) {
      const err = "PERM_DENY_WEB_SEARCH";
      step("Web search", "error", err);
      auditEvents.forEach(ev => auditAppendLine(ev, perms));
      auditAppendLine({ kind: "run_end", at: nowISO(), runId, ok: false, error: err }, perms);
      ssotAppend(baseRoot, `DENY web_search runId=${runId}`, perms);
      return { ok: false, error: err, proofJsonPath, fileOps: [] };
    }

    let searchRes;
    try {
      step("Web search", "running", "search");
      searchRes = await webSearch(searchQ, {
        count: 5,
        timeoutMs: 8000,
        maxBytes: 900_000,
        braveKey: (opts.braveSearchKey || "").trim(),
      });
      step("Web search", "ok", `provider=${searchRes.provider} results=${(searchRes.results || []).length}`);
    } catch (e) {
      const err = e && e.message ? e.message : "SEARCH_FAIL";
      step("Web search", "error", err);
      const proofObj = { ok:false, runId, at: nowISO(), runner_version: RUNNER_VERSION, feature_tag: "WEB_SEARCH", taskText, error: err, perms, audit_steps: auditEvents };
      writeFileProof(proofJsonPath, JSON.stringify(proofObj, null, 2));
      auditEvents.forEach(ev => auditAppendLine(ev, perms));
      auditAppendLine({ kind: "run_end", at: nowISO(), runId, ok: false, error: err, proofJsonPath }, perms);
      ssotAppend(baseRoot, `ERROR web_search=${err} runId=${runId}`, perms);
      return { ok:false, error: err, proofJsonPath, fileOps: [] };
    }

    // Save raw snapshot + results json
    const searchDir = path.join(proofsDir, "web_search");
    safeMkdir(searchDir);

    const rawSnap = clip(searchRes.raw || "", MAX_SEARCH_RAW_CHARS);
    const rawPath = path.join(searchDir, `${runId}_search_raw.txt`);
    const rawProof = writeFileProof(rawPath, rawSnap);
    fileOps.push({ op: "write", ...rawProof });

    const resultsPath = path.join(searchDir, `${runId}_search_results.json`);
    const resultsObj = {
      provider: searchRes.provider,
      query: searchRes.query,
      status: searchRes.status,
      contentType: searchRes.contentType,
      raw_bytes: searchRes.raw_bytes,
      raw_sha256: searchRes.raw_sha256,
      results: searchRes.results || [],
    };
    const resultsProof = writeFileProof(resultsPath, JSON.stringify(resultsObj, null, 2));
    fileOps.push({ op: "write", ...resultsProof });
    step("Write search proofs", "ok", `results_sha256=${resultsProof.sha256}`);

    // Read top 2 sources (guarded), then answer
    const sources = [];
    if (perms.web_read === true) {
      const top = (searchRes.results || []).slice(0, 2);
      for (let i = 0; i < top.length; i++) {
        const r = top[i];
        const u = String(r && r.url ? r.url : "").trim();
        if (!u || !/^https?:\/\//i.test(u)) continue;

        try {
          step("Web read", "running", `#${i + 1}`);
          const webRes = await webFetchGuarded(u, { maxBytes: 900_000, timeoutMs: 8000, maxRedirects: 4 });

          const webDir = path.join(proofsDir, "web");
          safeMkdir(webDir);
          const webText = clip(webRes.text || "", MAX_WEB_CHARS);
          const snapPath = path.join(webDir, `${runId}_read_${i + 1}.txt`);
          const snapProof = writeFileProof(snapPath, webText);
          fileOps.push({ op: "write", ...snapProof });

          sources.push({
            idx: i + 1,
            url: u,
            finalUrl: webRes.finalUrl,
            status: webRes.status,
            sha256: webRes.sha256,
            snapshot_path: snapPath,
            snapshot_sha256: snapProof.sha256,
            text: webText,
          });

          step("Web read", "ok", `#${i + 1} status=${webRes.status}`);
        } catch (e) {
          step("Web read", "error", `#${i + 1} ${(e && e.message) ? e.message : "WEB_READ_FAIL"}`);
        }
      }
    } else {
      step("Web read", "skipped", "PERM_DENY_WEB_READ");
    }

    const sourcesBlock = sources.length
      ? sources.map(s =>
          `SOURCE_${s.idx}:\nURL: ${s.finalUrl}\nSTATUS: ${s.status}\nSHA256: ${s.sha256}\nCONTENT:\n${s.text}\n`
        ).join("\n")
      : "NO_SOURCES_FETCHED.";

    const client = new OpenAI({ apiKey });
    const fullInput =
      `${ctx}` +
      `TASK:\n${taskText}\n\n` +
      `${formatSearchForPrompt(searchRes)}\n\n` +
      `SOURCES:\n${sourcesBlock}\n\n` +
      `INSTRUCTION:\nAnswer the TASK using ONLY SOURCES. If insufficient: INSUFFICIENT_WEB_DATA.`;

    step("OpenAI call", "running", "Responses API");
    const resp = await client.responses.create({
      model: "gpt-5.2",
      instructions: finalInstructions,
      input: fullInput,
      max_output_tokens: 520,
    });

    const outTextRaw = resp && resp.output_text ? resp.output_text : "(no output_text)";
    const outText = String(outTextRaw).trim();
    step("OpenAI call", "ok", `out_sha256=${sha256Text(outTextRaw)}`);

    const proofObj = {
      ok: true, runId, at: nowISO(),
      runner_version: RUNNER_VERSION,
      feature_tag: "WEB_SEARCH_ANSWER",
      taskText,
      history_count: history.length,
      openai_model: "gpt-5.2",
      output_sha256: sha256Text(outTextRaw),
      perms,
      search: {
        provider: searchRes.provider,
        query: searchRes.query,
        status: searchRes.status,
        contentType: searchRes.contentType,
        raw_bytes: searchRes.raw_bytes,
        raw_sha256: searchRes.raw_sha256,
        raw_snapshot_path: rawPath,
        raw_snapshot_sha256: rawProof.sha256,
        results_path: resultsPath,
        results_sha256: resultsProof.sha256,
        results_count: (searchRes.results || []).length,
      },
      sources: sources.map(s => ({
        idx: s.idx,
        url: s.url,
        finalUrl: s.finalUrl,
        status: s.status,
        sha256: s.sha256,
        snapshot_path: s.snapshot_path,
        snapshot_sha256: s.snapshot_sha256,
      })),
      fileOps,
      audit_steps: auditEvents,
    };

    const proofJson = JSON.stringify(proofObj, null, 2);
    const proof = writeFileProof(proofJsonPath, proofJson);
    step("Write proof JSON", "ok", `sha256=${proof.sha256}`);

    auditEvents.forEach(ev => auditAppendLine(ev, perms));
    auditAppendLine({ kind: "run_end", at: nowISO(), runId, ok: true, feature_tag: "WEB_SEARCH_ANSWER", proofJsonPath }, perms);
    ssotAppend(baseRoot, `DONE_OK WEB_SEARCH_ANSWER runId=${runId} proof=${proofJsonPath}`, perms);

    onLog("DONE.");
    return { ok: true, answer: outText, proofJsonPath, fileOps };
  }

  // --- WEB branch (explicit WEB:) ---
  const webCmd = parseWebCommand(taskText);
  if (webCmd && !webCmd.error) {
    if (perms.web_fetch !== true) {
      const err = "PERM_DENY_WEB_FETCH";
      step("Web fetch", "error", err);
      auditEvents.forEach(ev => auditAppendLine(ev, perms));
      auditAppendLine({ kind: "run_end", at: nowISO(), runId, ok: false, error: err }, perms);
      ssotAppend(baseRoot, `DENY web_fetch runId=${runId}`, perms);
      return { ok:false, error: err, proofJsonPath, fileOps: [] };
    }

    let webRes;
    try {
      step("Web fetch", "running", "guarded_fetch");
      webRes = await webFetchGuarded(webCmd.url, { maxBytes: 900_000, timeoutMs: 8000, maxRedirects: 4 });
      step("Web fetch", "ok", `status=${webRes.status} bytes=${webRes.bytes}`);
    } catch (e) {
      const err = e && e.message ? e.message : "WEB_FAIL";
      step("Web fetch", "error", err);
      const proofObj = { ok:false, runId, at: nowISO(), runner_version: RUNNER_VERSION, feature_tag: "WEB_FETCH", taskText, error: err, perms, audit_steps: auditEvents };
      writeFileProof(proofJsonPath, JSON.stringify(proofObj, null, 2));
      auditEvents.forEach(ev => auditAppendLine(ev, perms));
      auditAppendLine({ kind: "run_end", at: nowISO(), runId, ok: false, error: err, proofJsonPath }, perms);
      ssotAppend(baseRoot, `ERROR web_fetch=${err} runId=${runId}`, perms);
      return { ok:false, error: err, proofJsonPath, fileOps: [] };
    }

    const webDir = path.join(proofsDir, "web");
    safeMkdir(webDir);
    const webText = clip(webRes.text || "", MAX_WEB_CHARS);
    const webSnapPath = path.join(webDir, `${runId}_web.txt`);
    const webSnapProof = writeFileProof(webSnapPath, webText);
    fileOps.push({ op: "write", ...webSnapProof });

    const question = webCmd.question ? webCmd.question : "Riassumi i punti utili.";
    const fullInput =
      `${ctx}` +
      `WEB_SOURCE_URL: ${webRes.finalUrl}\n` +
      `WEB_SOURCE_STATUS: ${webRes.status}\n` +
      `WEB_SOURCE_SHA256: ${webRes.sha256}\n` +
      `WEB_CONTENT (truncated):\n${webText}\n\n` +
      `USER_QUESTION:\n${question}`;

    step("OpenAI call", "running", "Responses API");
    const client = new OpenAI({ apiKey });

    const resp = await client.responses.create({
      model: "gpt-5.2",
      instructions: finalInstructions + "\nUse ONLY WEB_CONTENT as your source. If insufficient: INSUFFICIENT_WEB_DATA.",
      input: fullInput,
      max_output_tokens: 420,
    });

    const outTextRaw = resp && resp.output_text ? resp.output_text : "(no output_text)";
    const outText = String(outTextRaw).trim();
    step("OpenAI call", "ok", `out_sha256=${sha256Text(outTextRaw)}`);

    const proofObj = {
      ok: true, runId, at: nowISO(),
      runner_version: RUNNER_VERSION,
      feature_tag: "WEB_FETCH_ANSWER",
      taskText,
      history_count: history.length,
      openai_model: "gpt-5.2",
      output_sha256: sha256Text(outTextRaw),
      perms,
      web: {
        url: webCmd.url,
        finalUrl: webRes.finalUrl,
        status: webRes.status,
        contentType: webRes.contentType,
        bytes: webRes.bytes,
        sha256: webRes.sha256,
        snapshot_path: webSnapPath,
        snapshot_sha256: webSnapProof.sha256,
      },
      fileOps,
      audit_steps: auditEvents,
    };

    const proofJson = JSON.stringify(proofObj, null, 2);
    const proof = writeFileProof(proofJsonPath, proofJson);
    step("Write proof JSON", "ok", `sha256=${proof.sha256}`);

    auditEvents.forEach(ev => auditAppendLine(ev, perms));
    auditAppendLine({ kind: "run_end", at: nowISO(), runId, ok: true, feature_tag: "WEB_FETCH_ANSWER", proofJsonPath }, perms);
    ssotAppend(baseRoot, `DONE_OK WEB_FETCH_ANSWER runId=${runId} proof=${proofJsonPath}`, perms);

    onLog("DONE.");
    return { ok:true, answer: outText, proofJsonPath, fileOps };
  }

  // --- Chat branch (no web) ---
  step("OpenAI call", "running", "Responses API");
  const client = new OpenAI({ apiKey });
  const fullInput = `${ctx}TASK:\n${taskText}`;

  const resp = await client.responses.create({
    model: "gpt-5.2",
    instructions: finalInstructions,
    input: fullInput,
    max_output_tokens: 320,
  });

  const outTextRaw = resp && resp.output_text ? resp.output_text : "(no output_text)";
  const outText = String(outTextRaw).trim();
  step("OpenAI call", "ok", `out_sha256=${sha256Text(outTextRaw)}`);

  const proofObj = {
    ok: true, runId, at: nowISO(),
    runner_version: RUNNER_VERSION,
    feature_tag: "CHAT",
    taskText, history_count: history.length,
    openai_model: "gpt-5.2",
    output_sha256: sha256Text(outTextRaw),
    perms,
    fileOps: [],
    audit_steps: auditEvents,
  };
  const proofJson = JSON.stringify(proofObj, null, 2);
  const proof = writeFileProof(proofJsonPath, proofJson);
  step("Write proof JSON", "ok", `sha256=${proof.sha256}`);

  auditEvents.forEach(ev => auditAppendLine(ev, perms));
  auditAppendLine({ kind: "run_end", at: nowISO(), runId, ok: true, feature_tag: "CHAT", proofJsonPath }, perms);
  ssotAppend(baseRoot, `DONE_OK CHAT runId=${runId} proof=${proofJsonPath}`, perms);

  onLog("DONE.");
  return { ok: true, answer: outText, proofJsonPath, fileOps: [] };
}

module.exports = { runTask };
